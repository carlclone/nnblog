todoo 

# 正则表达式引擎学习

要实现的是支持普通字符串匹配, 支持 . 和 * 符号匹配的正则引擎

. 很好理解, 匹配任意一个字符, 和普通字符串一样 matchOne 函数处理 就可以了

*表示匹配上一个字符的 0 次或 n 次 , 所以需要额外的 matchStar 函数 对*进行特殊处理

子问题已经找到了 , 接下来寻找子问题重叠的部分, 用记忆化来降低复杂度

用一个例子来找重复子问题

```
p = a*ab

s = aaab
```

第一条路径匹配 a , 0 次 , 最后匹配失败, (匹配 0 次的结果不记忆也可以)

第二条匹配 a 1 次, 那么p[1]和 s[0] 就成功匹配了 , 虽然最后也匹配失败了, 但是 p[1] , s[0] 成功匹配这个结果可以在后面的路径用上

第三条路径,匹配 a 2 次, 因为 p[1]和 s[1]已经匹配过了, 所以这次可以直接从 p[1]和 s[1] 开始匹配 , 也成功匹配, 并且最后完全匹配成功

至此就找到了重复子问题

##递归+记忆化的做法

TODO;

## 动态规划的做法

TODO;

有了上面递归过程对重复子问题的定义, 动态规划的状态和状态转移就一目了然了 , 状态就是 p[x]和 s[y]的匹配结果 , 用二维数组 dp[x][y]保存
状态转移就是(画一个状态机) , 从之前的 dp[x][y] 是否可以转换到 dp[x+1][y] 或 dp[x][y+1]或 dp[x+1][y+1] , 

## 结尾

经过在 build-your-own-x 的正则引擎项目和极客时间的编译原理中词法分析中的状态机学习后, 对动态规划所描述的"状态"和"状态转移"有了新的认识
动态规划题目也变得不这么难懂了

这里是递归和动态规划的写法, NFA 和 DFA 的还需要深入学习

## 参考资料

[A Regular Expression Matcher](https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html)

[Build a Regex Engine in Less than 40 Lines of Code](https://nickdrane.com/build-your-own-regex/)