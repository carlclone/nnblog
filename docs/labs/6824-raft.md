---
title: mit 6.824 小记
date: 2020-04-23
tags: 计算机基础
---

&nbsp;

<!-- more -->

## Lab2 Raft

记录1 : debug了4个小时 , 发现总有一个情况全部follower都会变成candidate , 看了测试用例 , 发现是断开了第一个leader , 导致了发送投票请求阻塞在这个leader上超时了
解决方案: 把每个发送请求放到一个goroutine里并发执行

记录2:给他人投票的时候忘记重置超时时间了

记录3:多线程debug好痛苦,只能到处打印,有没有其他好方法啊

记录4:Lab2A 使用了之前分布式调度项目和Chrome V8引擎学到的事件循环模型,
全部事件经由管道交给Eventloop线程执行 ,避免了锁的使用,感觉给2B,2C开了个好头

记录5:etcd的raft是类似一个状态机的设计,完全看不懂,后面想学学

记录6:频繁使用channel导致peer同时超时 , 课堂老师推荐用shared data + lock 有这个原因吧?

7:未加锁或者waitGroup , 导致超时后的投票请求和超时前的叠加在一起 , 在peers数不足的时候获得多数投票的假象








```
rf.mu.Lock()
  rf.currentTerm += 1
  rf.state = Candidate
  for <each peer> {
    go func() {
      rf.mu.Lock()
      args.Term = rf.currentTerm
      rf.mu.Unlock()
      Call("Raft.RequestVote", &args, ...)
      // handle the reply...
    } ()
  }
  rf.mu.Unlock()

go发现有其他goroutine引用了变量currentTerm , 把currentTerm移到了堆空间里 , 主和子goroutine都看到同一个任期变量 , 导致变化的时候每个peer看到的可能不一致 , 
所以需要将任期以参数穿进去 , 此时go会对每个goroutine的currentTerm进行一次拷贝 , 保证任期的一致
```



