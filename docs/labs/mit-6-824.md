---
title: mit 6.824 小记
date: 2020-04-23
tags: 计算机基础
---

&nbsp;

<!-- more -->

## Lab2 Raft

记录1 : debug了4个小时 , 发现总有一个情况全部follower都会变成candidate , 看了测试用例 , 发现是断开了第一个leader , 导致了发送投票请求阻塞在这个leader上超时了
解决方案: 把每个发送请求放到一个goroutine里并发执行

记录2:给他人投票的时候忘记重置超时时间了

记录3:多线程debug好痛苦,只能到处打印,有没有其他好方法啊

记录4:Lab2A 使用了之前分布式调度项目和Chrome V8引擎学到的事件循环模型,
全部事件经由管道交给Eventloop线程执行 ,避免了锁的使用,感觉给2B,2C开了个好头

记录5:etcd的raft是类似一个状态机的设计,完全看不懂,后面想学学

记录6:频繁使用channel导致peer同时超时 , 课堂老师推荐用shared data + lock 有这个原因吧?

7:未加锁或者waitGroup , 导致超时后的投票请求和超时前的叠加在一起 , 在peers数不足的时候获得多数投票的假象

## Lab1 MapReduce
第一个 lab 的 test case 在今天全部稳定 pass 了 , 比起平时写业务一条路写到底 , 分布式带来了许多新鲜感 , 要考虑的的东西也从单线程变成了多线程并发,各种 race 条件 , 很多时候没有良好的定义就只能全部推翻重来了

这里有一篇关于[锁的文章](https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt)

虽说 test case 是 pass 了 , 但是论文里提到的很多点依然很值得动手实现 , 主要是 fault tolerance 相关的功能 , 比如我的代码里就没有考虑到在写文件的时候崩溃的场景 , 或者 worker 完成了task但是已经失活 , 还有 master crash 后 , 如何进行 recovery  (对重要状态进行持久化 , 日志追加)

我的学习过程是直接看 Lec1 的 intro , 然后是 mapreduce paper , 
虽然老师长得很帅 (神牛 robert morris , 蠕虫病毒作者 , 老爸是安全局科学家 ,羡慕了), 但是之前看过分布式的相关理论 , mapreduce 又是类似大文件分割统计的面试题泛化 ,  视频和 lec2就跳过了

第一次读论文 , 感觉学一个概念 , 读最原始的论文 , 似乎少了很多疑惑和额外的搜索

但是raft 的论文已经看了两天了 , 还没有开始动手 , 哈哈哈


[mit-6.824 labs](https://github.com/carlclone/MIT-6.824-LAB.git/)


```
mapreduce

input is (already) split into M files
  Input1 -> Map -> a,1 b,1
  Input2 -> Map ->     b,1
  Input3 -> Map -> a,1     c,1
                    |   |   |
                    |   |   -> Reduce -> c,1
                    |   -----> Reduce -> b,2
                    ---------> Reduce -> a,2

解决的问题:
让用户只需要关心 map 和 reduce
隐藏:
sending app code to servers
  tracking which tasks are done
  moving data from Maps to Reduces
  balancing load over servers
  recovering from failures

MapReduce single-handedly made big cluster computation popular.
  - Not the most efficient or flexible.
  + Scales well.
  + Easy to program -- failures and data movement are hidden.
  These were good trade-offs in practice.
  We'll see some more advanced successors later in the course.
  Have fun with the lab!
```


```
rf.mu.Lock()
  rf.currentTerm += 1
  rf.state = Candidate
  for <each peer> {
    go func() {
      rf.mu.Lock()
      args.Term = rf.currentTerm
      rf.mu.Unlock()
      Call("Raft.RequestVote", &args, ...)
      // handle the reply...
    } ()
  }
  rf.mu.Unlock()

go发现有其他goroutine引用了变量currentTerm , 把currentTerm移到了堆空间里 , 主和子goroutine都看到同一个任期变量 , 导致变化的时候每个peer看到的可能不一致 , 
所以需要将任期以参数穿进去 , 此时go会对每个goroutine的currentTerm进行一次拷贝 , 保证任期的一致
```



