这里我有个问题, 平时业务开发中的 Service , Repository 这些类, 需要放到容器中吗 , 不需要的话, 在哪里 new 呢

因为业务代码是不需要关注框架部分的东西的 , 所以控制器的上一层就相当于业务逻辑的""最外层" , 注入的话注入控制器就好了 , new 的操作交给控制器的上层负责

但是这样上层不就和 service 和 repository 形成依赖了吗 , 所以在 JAVA 的 spring boot 框架中这些类是通过注解的形式注入的 (在微服务那门课程看到的)  , 而 PHP 中也有好的实现方式 , 通过反射注入, 这样就顺利解开了依赖, 可测试, 易于修改两个痛点都解决了



另一个问题是, 通常一个 service 可能依赖多个 repository , 这样在启动的时候实例化如此多的类可能会造成性能问题? 并且可能在这次运行中大部分都用不到, 想到的一个解决方案是也把 repository 放到容器里, 但这样容器会非常肿大, 第二个解决方案是注入一个repository 的 factory 到 service 里, 使用的时候 `$this->repositoryFactory->create('xxxRepository') ` , 目前可能第二个方案比较能接受, 后面看看 Doctrine 官方的解决方案, 似乎有个 EntityManager 和 EntityRepository 的设计 , 或者考虑 repository 到底需不需要注入



还有第三方库的依赖问题, 这个在 Laravel 里已经见过许多了, 都是通过 ServiceProvider 定义, 注入到容器中



两个 service 循环依赖, 导致反射注入失败的问题 , 首先这样的 service 职责设计是否合理, 也许不应该出现循环依赖,   

其次解决方案是用容器将实例化过程描述好



这都够另开一篇讲了, 几乎就要做成单体里的微服务了



整一个做下来全是面向对象的东西, 和一些基础学习相比, 可以说是非常实用 (工作上) 的一次实践了, 并且之前有接触到 Spring boot 开发微服务的一套东西, 相互之间一对比, 很多东西就贯通了, 在面向对象这方面, Java 还是大哥大



微服务的角度 ,  service 从注册中心里获取 , repository 有 repository manager / factory

第三方库要怎么注入 service等依赖于容器 容器定义接口的实现 要换实现的话用适配器将另一个库适配该接口就好了 这是我目前想的业务开发高扩展性方案

因为是最外层了 new不new无所谓 没有谁依赖谁的说法了