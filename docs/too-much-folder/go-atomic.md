# 赋值取值操作为什么不是原子的

在阅读bytebufferpool和workerpool代码的时候经常看到atomic.LoadUInt64 , atomic.LoadInt32 , atomic.StoreInt32 等函数调用，产生了一个疑问，为什么整数操作要用到原子包里的东西

一番搜寻后，得到一个答案是64位的操作在32位上并不是由一个指令完成的，而是分成前32位和后32位两部分操作完成，因此整个操作没有原子性保证

那要如何在32位机器上实现64位的原子操作呢？ 先分析一下可能出现的情况

1. 执行完第一部分后，上下文切换到其他线程，其他线程读取该值，导致问题
2. 多cpu，多核，有cpu cache的情况下，单个指令有硬件的缓存一致性协议保证，多个指令的话无法保证 ， 也导致问题
3. 编译器对代码进行优化，打乱顺序，导致问题


问题1是可见性的问题，读取同样也要加内存屏障持， 这样即使发生了线程切换， 另一个线程也不会看到赋值到一半的int64 , 同时也提供了happens-before的保证
问题2是原子性问题， 使用硬件提供的内存屏障指令，被内存屏障指令包围的操作只有在全部完成后才写入内存 （类似数据库里的事务BEGIN和COMMIT)
问题3是有序性问题， 也由内存屏障提供， 阻止编译器,cpu的执行优化 ， go中甚至有的整数操作代码是直接用汇编写的 (数据库也会对语句乱序执行，但是在保证执行结果和顺序执行一致的情况下)



那为什么还有32位的原子操作呢，难道是提供给16位机器使用？

GOARCH可以指定机器架构交叉编译，先看看go提供了哪些平台编译支持 , 并没有看到16位的参数

```
darwin/386
darwin/amd64
darwin/arm
darwin/arm64
```

用gdb分别调试64位下和32位下的LoadInt32 汇编代码 , 没有区别

还可以使用go tool compile查看汇编代码

再看看arm64的汇编 ， 不是原子的


从这篇文章里得知还可以通过这种方式阅读到go更底层的实现， 原来arm64的Loadint32操作是直接用汇编代码写的

## 末

所以这些知名的库为了提供给更多不同平台的机器使用，使用了int原子操作


资料

https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C

https://liqiang.io/post/view-all-GOOS-and-GOARCH-for-go-3c2beacc